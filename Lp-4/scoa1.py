# -*- coding: utf-8 -*-
"""SCOA1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yeoNUF1MYBJYCXW1fSAYQVDaTv2Vf5SB

CREATE
"""

class FuzzySet:
  def __init__(self):
    self.__s = set()
    self.__mem = {}

  def __str__(self):
    return f'{[(x, self.__mem[x]) for x in self.__s]}'

  def __len__(self):
    return len(self.__s)

  def add(self, val, mem_val):
    assert mem_val >= 0 and mem_val <= 1, 'Membership value must be in the range [0, 1].'
    if val not in self.__s:
      self.__s.add(val)
      self.__mem[val] = mem_val

  def union(self, other):
    res = FuzzySet()
    for x in self.__s:
      if x not in other.__s: res.add(x, self.__mem[x])
      else: res.add(x, max(self.__mem[x], other.__mem[x]))
    for x in other.__s:
      if x not in self.__s: res.add(x, other.__mem[x])
    return res

  def intersect(self, other):
    res = FuzzySet()
    for x in self.__s:
      if x not in other.__s: res.add(x, self.__mem[x])
      else: res.add(x, min(self.__mem[x], other.__mem[x]))
    for x in other.__s:
      if x not in self.__s: res.add(x, other.__mem[x])
    return res

  def complement(self):
    res = FuzzySet()
    for x in self.__s:
      if self.__mem[x] < 1: res.add(x, round(1 - self.__mem[x], 1))
    return res

  def minus(self, other):
    temp = other.complement()
    return self.intersect(temp)

  def cartesian_product(self, other):
    res = [[None for _ in range(len(other))] for _ in range(len(self))]
    for i, x in enumerate(self.__s):
      for j, y in enumerate(other.__s):
        res[i][j] = (x, y, min(self.__mem[x], other.__mem[y]))
    return res

  @staticmethod
  def compose(a, b):
    assert len(a[0]) == len(b), 'Dimension mismatch.'
    m, r, n = len(a), len(a[0]), len(b[0])
    for i in range(r):
      assert a[0][i][1] == b[i][0][0], 'Non-compatible relations.'
    res = [[None for _ in range(m)] for _ in range(n)]
    for i in range(m):
      for j in range(n):
        val = 0
        for k in range(r):
          val = max(val, min(a[i][k][2], b[k][j][2]))
        res[i][j] = (a[i][0][0], b[0][j][1], val)
    return res

fs1 = FuzzySet()
fs2 = FuzzySet()
fs3 = FuzzySet()

fs1.add('x1',0.7)
fs1.add('x2',0.2)

fs2.add('y1',0.9)
fs2.add('y2',0.5)

fs3.add('z1',0.8)
fs3.add('z2',0.6)

"""UNION

"""

fs_1_or_2 = fs1.union(fs2)
print(fs_1_or_2)

fs_2_or_3 = fs2.union(fs3)
print(fs_2_or_3)

"""INTERSECTION"""

fs_1_and_2 = fs1.intersect(fs2)
print(fs_1_and_2)

fs_2_and_3 = fs2.intersect(fs3)
print(fs_2_and_3)

"""COMPLEMENT"""

fs_not_1 = fs1.complement()
print(fs_not_1)

fs_not_2 = fs2.complement()
print(fs_not_2)

fs_not_3 = fs3.complement()
print(fs_not_3)

"""DIFFERENCE"""

fs_1_minus_2 = fs1.minus(fs2)
print(fs_1_minus_2)

fs_2_minus_3 = fs2.minus(fs3)
print(fs_2_minus_3)

"""CARTESIAN PRODUCT"""

a = fs1.cartesian_product(fs2)
a

b = fs2.cartesian_product(fs3)
b

"""COMPOSITION"""

res = FuzzySet.compose(a, b)
res