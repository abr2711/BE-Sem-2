# -*- coding: utf-8 -*-
"""SCOA2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w1DnLexCMA8YZ0viEYLIuh4SC6tqA7se
"""

import numpy as np
np.random.seed(42)

"""
STEPS:
  - Maximize fitness function x ** 2 for 8 bit individuals
  - Choose initial sample from normal distribution (sample size = 8)
  - Apply following n times:
    - Calculate fitness of each individual
    - Select some individuals using tournament selection (select 8, with tournament size 4)
    - Apply one point crossover on selected individuals (with given probability)
    - Apply bit flip mutation on offsprings (with given probability)
    - Set offsprings as current population
"""

def dec_to_bin(x, n):
  b = bin(x).replace('0b', '')
  return '0' * max((n - len(b)), 0) + b

class BitPopulation:
  def __init__(self, length, initial_size, tournament_size, cross_prob, flip_prob):
    self.length = length
    self.size = initial_size
    self.__init_population()
    self.k = tournament_size
    self.pc = cross_prob
    self.pf = flip_prob
    assert self.k <= self.size, 'Tournament size greater tha population size.'
    assert self.pc >= 0 and self.pc <= 1, 'Invalid crossover probability.'
    assert self.pf >= 0 and self.pf <= 1, 'Invalid flipping probability.'

  def __init_population(self):
    mean = 2 ** (self.length - 2)
    std = mean / 2
    max_val = 2 ** self.length - 1
    population = np.random.normal(mean, std, self.size)
    self.__population = [int(max(0, min(max_val, x))) for x in population]

  def get_popultation(self):
    # return self.__population.copy()
    return [dec_to_bin(x, self.length) for x in self.__population]

  def display_population(self):
    for x in self.__population:
      print(f'{dec_to_bin(x, self.length)}: {x}')
    print()

  def __fitness(self, x):
    return x * x

  def __tournament_selection(self):
    pop_fit = [self.__fitness(x) for x in self.__population]
    return [int(np.sqrt(np.max(np.random.choice(pop_fit, self.k)))) for _ in range(self.size)]

  def __crossover(self, x, y):
    if np.random.rand() > self.pc: return x, y

    limit = np.random.randint(self.length)
    x = list(dec_to_bin(x, self.length))
    y = list(dec_to_bin(y, self.length))
    for i in range(limit, self.length):
      temp = x[i]
      x[i] = y[i]
      y[i] = temp
    x = ''.join(x)
    y = ''.join(y)
    return int(x, 2), int(y, 2)

  def __mutate(self, x):
    x = list(dec_to_bin(x, self.length))
    for i in range(self.length):
      if np.random.rand() <= self.pf:
        x[i] = '0' if x[i] == '1' else '1'
    x = ''.join(x)
    return int(x, 2)

  def __generate_offsprings(self):
    # APPLY TOURNAMENT SELECTION
    offsprings = self.__tournament_selection()
    # APPLY CROSSOVER
    for i in range(1, self.size, 2):
      offsprings[i-1], offsprings[i] = self.__crossover(offsprings[i-1], offsprings[i])
    # APPLY MUTATION
    for i in range(self.size):
      offsprings[i] = self.__mutate(offsprings[i])
    return offsprings

  def fit(self, generations):
    print('INITIAL POPULATION:')
    self.display_population()
    for i in range(generations):
      self.__population = self.__generate_offsprings()
      print(f'GENERATION {i+1}: ')
      self.display_population()

population = BitPopulation(8, 8, 4, 0.9, 0.001)

population.display_population()

population.fit(100)